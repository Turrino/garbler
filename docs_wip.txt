WRGRBRLER

Breadcrumbs
	Main level >
		Categories: nodes that are only used to categorise lists of crumblists (templates, characters, locations, etc). Can be nested. Has to be a dictionary.
		    >   Crumblists: a list of lists of positional elements (strings or subsets)
		        >   Positional Element: a word or sentence to be used as building block. e.g. 1/2/3rd component of a name or sentence.
				    Subset: expands a single positional element into a list of positional elements that can be used for contextual reasons (e.g. male/female).
				    Can be any length.

    Events in crumbs:
        Events are structured as Blocks>Variants>Segments>Outcomes
        Each event pattern lives in its own file (files/events). I
            Block: list of variants and a fork pointing to other blocks
            Variants: lists of segments; one set of segments is randomly chosen (e.g. no multipliers or lucky dust)
            Segment: each segment has multiple possible outcomes, only one is chosen (using multipliers)
            Outcomes: has a text skeleton that goes to compose the overall event; also defines if there are drops or not
                Drops: defines if an outcome drops lucky dust or not, and any item drops (as well as any other special drop)

Events v2:
    Events marked with type "intro" can be used as starting point. This needs to be specified in block_type_definitions
    Inside events, the single items in the branches can have any ids, as long as the pointers are correct.
    The first item at the top of the branches list will be the one used to start off the event.
    The other nodes can be in any order.

Metadata lookup (meta_lookup):
    A dictionary that stores metadata for different kind of objects (both categories and crumblists). The name of the object is the key.
    Returns an object that contains information that can be used to:
         - Provide context (e.g. if a generated object is passed around inside an event)
         - Provide graphical asset information (filename, overlay position, filters, ...)
    Not all entries in the crumbs need to have a key in here, but if they don't, the information from their parent category will be used instead,
    all the way up to the root-category level, so at least those need to have the necessary information, or the lookup will fail.


Items drops:
    In crumbs: "items" example: [["type_a",2,50],["type_b",1,100]]
     items is a list of possible drops, each entry in the list containing:
     - Item type
     - Item maximum tier (upper limit for the random range)
     - Rate of drop (percentage points)
     When generating an item: for each tier, the generator will have an amount of points (fixed at 2, could be configurable)
      that will be randomly allocated in sections, either mods or durability.
       Each section will have at least 1pt / 10% of the points, whichever is smaller

Lucky Dust (LD)
    Can be carried, not an item. Affects events. The amount carried is defined at the start of the events.
    Note about branch length and dust: currently we distribute ld at each segment, using the deepest possible branch
    as a distribution parameter. However, if the branch is the deepest branch is not the one we actually go through,
    we end up with shorter brnaches having an unfair ld allocation. At the moment the solution is to keep the depth
    of all branches similar (+/- 10%), but this needs fixing somehow.

Peeps	
	Properties
		Gender: 0 for female, 1 for male
		
Location
	Properties
	
Event
	Properties
		Mood: determines the direction this event will take. 0: downward, 1: neutral, 2: upward			

Replacements syntax:
    Replacements must start and end with the @ character and match a crumblist name: "i want an @type_a@"
    To specify the path of a crumblist, use commas: "i want an @items,type_a#2,5@"
    If the path is not specified, and a single crumblist name is present, the crumblist's path will be looked up.
    "@items@" is not valid because it is a category and not a crumblist.
    To get a replacement without specifying the path past a certain level, use the ~ tag:
     "i want an @items,~@". Here items with the ~ tag works because the writer will traverse crumbs at random,
      past the items node, until an actual crumblist is found.
    If a generated object is to be displayed, use the # tag, followed by the overlay channel index,
    before the closing @ tag: "i want an @type_a#1@"
    To specify the position in the overlay channel, use two comma separated numbers: "i want an @type_a#2,5@"
    To specify a subset (e.g. male, female), use the $ tag followed by the subset index: "i want an @items,~$0#2,5@"
    For any of the above: do not include spaces.

Passing replacements around:
    The above rules apply, except and id has to be supplied, surrounded by the symbol '£', e.g.:
        "i want an @£id44£items,type_a#2,5@"
    To re-use elements from the cache, use a single '%' and the id:
        "i want that @%id44@ again"
    If the '%' symbol is used, then only the id can be specified - the rest of the metadata is loaded from the cache
     and cannot be changed (we'll want to allow some modifications, but it's not a feature yet)

Using the writer and get element:
    Example syntax:
    a = x.get_element("type_a") > gets the instructions from crumbs_v2 for (item) type_a, returns a complete object
    b = x.get_element("sample_instructions") > gets the instructions from crumbs_v2 "sample_instructions", returns a complete object
    c = x.writerer("role item_adj loc_tail") > explicit instructions (not from crumbs_v2), gets the specified crumblists from the vocabulary


Image generation
    Overlays
        Channels:
        Eigth channels for now, if we ever need more: make this more flexible.
            (255, 0, 0) (red) = ?
            (255, 170, 0) (orange) = ?
            (212, 255, 0) (lime) = ?
            (0, 255, 85) (green) = ?
            (0, 255, 255) (cyan) = ?
            (0, 85, 255) (blue) = ?
            (85, 0, 255) (violet) = ?
            (255, 0, 255) (pink) = ?
		
To do's:
- Schema check on the breadcrumbs (ensure that if an event needs to generate something,
 it will always have sufficient elements to do so, and will not crash)
	Worst case scenario: garbler crashes, re-run it until it hits a scenario where it has enough assets to work with
	 (and pretend that nothing happened).


